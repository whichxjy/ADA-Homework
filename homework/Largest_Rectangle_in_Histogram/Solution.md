# Solution

**解法 1：**

暴力搜索。从左至右扫描每个立柱，然后以这个立柱为左边界，再向右扫描寻找右边界，在这个过程中找出所有可能的矩阵，求出面积最大的那个。时间复杂度为 O(n^2)。

**解法 2：**

对暴力搜索法进行剪枝。扫描每个立柱，每找到一个局部峰值（只要当前的数字大于后面的一个数字，那么当前数字就看作一个局部峰值，跟前面的数字大小无关），然后向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值。就拿题目中的示例来说，当扫描到 5 的时候，发现比右边的 6 小，这时可以继续扫描下一个，不用再往左遍历计算面积。这是因为 6 的高度大于 5，所以从 6 开始往左计算的面积肯定大于或等于从 5 往左计算的面积，也就是说，非局部峰值的情况可以由后面的局部峰值包括，因此也就没有必要从 5 往左计算面积了。接下来，扫描到 6 的时候，发现 6 比右边的 2 大，此时 6 为局部峰值，可以往左开始遍历计算矩形面积。总体来说，此示例中总共有 2 个局部峰值：2 和 6，再加上最后一个 3，只需要进行 3 次往左求面积的操作。此算法对解法 1 进行了优化，但是时间复杂度仍然是 O(n^2)。

**解法 3：**

使用单调栈求解。栈中存储的是立柱的序号，而非立柱的高度。根据木桶原理，所求矩阵的面积受限于最低的那块板，所以应该优先选更高的立柱开始计算。因此，应该使用递增栈（单调栈分为递增栈和递减栈）来解题。栈底的序号对应的立柱最矮，自此向上，栈顶的序号对应的立柱最高。通过这种设置，就可以通过处理栈顶来优先处理最高的立柱，再接着处理旁边矮一点的立柱。

从左到右遍历各个立柱，如果递增站为空，或者当前扫描的立柱高于栈顶序号对应的立柱，则将当前立柱的序号压入栈中，然后继续扫描下一个立柱。而如果当前扫描的立柱的高度小于栈顶序号对应的立柱高度，则触发计算矩形面积的任务（而不用继续扫描下一个立柱）。可以看出，递增栈中保留了到当前为止，所有可能要参与矩形面积计算的立柱序号。计算面积时，先将栈顶的序号弹出，如果栈顶元素弹出后栈变为空，则表明弹出的立柱序号是唯一可参与计算面积的序号，此时的矩阵面积为弹出序号对应的高度（矩阵高度）乘以当前的扫描序号（矩阵宽度，从 0 到 index - 1）。而如果栈顶元素弹出后栈中仍有元素，则当前的栈顶元素是下一个可能用于计算面积的元素，可先忽略它，此时的矩阵面积为弹出序号对应的高度（矩阵高度）乘以从当前扫描序号到栈顶元素序号的下一序号的长度（矩阵宽度，从 stack.top() + 1 到 index - 1）。继续这一过程，直到当前扫描的立柱高于栈顶序号对应的立柱高度，然后再次将当前扫描的立柱序号入栈。